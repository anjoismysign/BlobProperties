package io.github.anjoismysign.blobproperties.entity;

import io.github.anjoismysign.bloblib.BlobLib;
import io.github.anjoismysign.bloblib.BlobLibAPI;
import io.github.anjoismysign.bloblib.api.BlobLibSoundAPI;
import io.github.anjoismysign.bloblib.api.BlobLibTranslatableAPI;
import io.github.anjoismysign.bloblib.entities.DataAssetType;
import io.github.anjoismysign.bloblib.entities.positionable.Locatable;
import io.github.anjoismysign.bloblib.entities.translatable.BlobTranslatableBlock;
import io.github.anjoismysign.bloblib.entities.translatable.BlobTranslatablePositionable;
import io.github.anjoismysign.bloblib.entities.translatable.TranslatableBlock;
import io.github.anjoismysign.bloblib.entities.translatable.TranslatablePositionable;
import io.github.anjoismysign.bloblib.utilities.TextColor;
import io.github.anjoismysign.blobproperties.BlobProperties;
import io.github.anjoismysign.blobproperties.api.BlobPropertiesAPI;
import io.github.anjoismysign.blobproperties.api.Property;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.block.data.Bisected;
import org.bukkit.block.data.type.Door;
import org.bukkit.entity.Player;
import org.bukkit.util.BlockVector;
import org.bukkit.util.Vector;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

public interface InternalProperty extends Property {

    static final BlobPropertiesAPI API = BlobPropertiesAPI.getInstance();

    Set<BlockVector> getDoors();

    Map<BlockVector, Container> getContainers();

    @NotNull
    default String displayName(@Nullable Player player) {
        String locale = player != null ? player.getLocale() : "en_us";
        return getOutside(locale).getDisplay();
    }

    @Override
    @NotNull
    default List<String> lore(Player player) {
        TranslatableBlock block = getLore(player);
        List<String> lore = new ArrayList<>();
        block.get().forEach(s -> {
            s = s.replace("%price%",
                            API == null ? "&4REPORT: NO API" : API.format(getCurrency(), getPrice()))
                    .replace("%world%", getWorld().getName())
                    .replace("%key%", identifier())
                    .replace("%identifier%", identifier())
                    .replace("%displayName%", displayName(player))
                    .replace("%containers%", getContainersAmount() + "")
                    .replace("%rows%", getRowsAmount() + "")
                    .replace("%slots%", getContainersAmount() * 9 + "");
            s = TextColor.PARSE(s);
            lore.add(s);
        });
        return lore;
    }

    @Override
    @NotNull
    default World getWorld() {
        return Objects.requireNonNull(
                getOutside("en_us").get().toLocation().getWorld(),
                "No world found for " + getMeta().typeName() + " '" + identifier() + "'");
    }

    default long getContainersAmount() {
        return getContainers().size();
    }

    default long getRowsAmount() {
        return getContainers().values().stream().mapToLong(Container::getRows).sum();
    }

    @NotNull
    default TranslatableBlock getLore(@NotNull Player player) {
        String reference = useDefaultLore() ? "BlobProperties.Property-Lore" :identifier() + "_lore";
        try {
            return Objects.requireNonNull(
                    BlobLibTranslatableAPI.getInstance().getTranslatableBlock(reference, player.getLocale()),
                    "No TranslatableBlock under " + getMeta().typeName() + " '" + reference + "'");
        } catch (Throwable throwable) {
            BlobTranslatableBlock block = BlobTranslatableBlock.of(reference, "en_us", List.of("Write down the lore, this was autogenerated"));
            File directory = BlobProperties.getInstance().getManagerDirector().getFileManager().getDirectory(DataAssetType.TRANSLATABLE_BLOCK);
            File file = new File(directory, reference + ".yml");
            BlobLib.getInstance().getTranslatableManager().saveBlock(file, block);
            return block;
        }
    }

    @NotNull
    default TranslatablePositionable getInside(@NotNull String locale) {
        String reference = identifier() + "_inside";
        try {
            return Objects.requireNonNull(BlobLibTranslatableAPI.getInstance().getTranslatablePositionable(reference, locale),
                    "No TranslatablePositionable under " + getMeta().typeName() + " '" + reference + "'");
        } catch (Throwable throwable){
            World world = Bukkit.getWorlds().get(0);
            BlobTranslatablePositionable positionable = BlobTranslatablePositionable.of(
                    reference,
                    "en_us",
                    "Autogenerated",
                    new Locatable() {
                        @Override
                        public @NotNull World getWorld() {
                            return world;
                        }

                        @Override
                        public float getYaw() {
                            return 0;
                        }

                        @Override
                        public float getPitch() {
                            return 0;
                        }

                        @Override
                        public double getX() {
                            return 0;
                        }

                        @Override
                        public double getY() {
                            return 0;
                        }

                        @Override
                        public double getZ() {
                            return 0;
                        }
                    });
            File directory = BlobProperties.getInstance().getManagerDirector().getFileManager().getDirectory(DataAssetType.TRANSLATABLE_POSITIONABLE);
            File file = new File(directory, reference + ".yml");
            BlobLib.getInstance().getTranslatablePositionableManager().saveAsset(file, positionable);
            return positionable;
        }
    }

    @NotNull
    default TranslatablePositionable getOutside(@NotNull String locale) {
        String reference = identifier() + "_outside";
        try {
            return Objects.requireNonNull(
                    BlobLibTranslatableAPI.getInstance().getTranslatablePositionable(reference, locale),
                    "No TranslatablePositionable under " + getMeta().typeName() + " '" + reference + "'");
        } catch (Throwable throwable){
            World world = Bukkit.getWorlds().get(0);
            BlobTranslatablePositionable positionable = BlobTranslatablePositionable.of(
                    reference,
                    "en_us",
                    "Autogenerated",
                    new Locatable() {
                        @Override
                        public @NotNull World getWorld() {
                            return world;
                        }

                        @Override
                        public float getYaw() {
                            return 0;
                        }

                        @Override
                        public float getPitch() {
                            return 0;
                        }

                        @Override
                        public double getX() {
                            return 0;
                        }

                        @Override
                        public double getY() {
                            return 0;
                        }

                        @Override
                        public double getZ() {
                            return 0;
                        }
                    });
            File directory = BlobProperties.getInstance().getManagerDirector().getFileManager().getDirectory(DataAssetType.TRANSLATABLE_POSITIONABLE);
            File file = new File(directory, reference + ".yml");
            BlobLib.getInstance().getTranslatablePositionableManager().saveAsset(file, positionable);
            return positionable;
        }
    }

    default boolean placeOutside(@NotNull Player player) {
        TranslatablePositionable outside = getOutside(player.getLocale());
        Location playerLocation = player.getLocation();
        float yaw = playerLocation.getYaw();
        float pitch = playerLocation.getPitch();
        Location location = outside.get().toLocation().clone();
        location.setYaw(yaw);
        location.setPitch(pitch);
        player.teleport(location);
        BlobLibSoundAPI.getInstance().getSound("Property.Door-Outside").handle(player);
        return true;
    }

    default boolean placeInside(@NotNull Player player) {
        TranslatablePositionable inside = getInside(player.getLocale());
        Location playerLocation = player.getLocation();
        float yaw = playerLocation.getYaw();
        float pitch = playerLocation.getPitch();
        Location location = inside.get().toLocation().clone();
        location.setYaw(yaw);
        location.setPitch(pitch);
        player.teleport(location);
        BlobLibSoundAPI.getInstance().getSound("Property.Door-Inside").handle(player);
        return true;
    }

    default boolean containsDoor(@NotNull Block door) {
        BlockVector vector = door.getLocation().toVector().toBlockVector();
        return getDoors().contains(vector);
    }

    default String buildKey(@NotNull Vector vector) {
        return getWorld().getName() + ":" + vector.getBlockX() + " " + vector.getBlockY() + " " + vector.getBlockZ();
    }

    @NotNull
    default String getContainer(Block block) {
        return getContainers().get(block.getLocation().toVector().toBlockVector()).getKey();
    }

    default int getContainerRows(Block block) {
        return getContainers().get(block.getLocation().toVector().toBlockVector()).getRows();
    }

    /**
     * Adds a container to the property
     *
     * @param block the block of the container
     * @param rows  the rows of the container
     * @return true if the container was added, false if the container already exists
     */
    default boolean addContainer(@NotNull Block block, int rows) {
        if (containsContainer(block))
            return false;
        Vector vector = block.getLocation().toVector();
        getContainers().put(vector.toBlockVector(), Container.of(vector, rows, buildKey(vector)));
        save();
        return true;
    }

    /**
     * Removes the container from the property
     *
     * @param block the block of the container
     * @return true if the container was removed, false if the container was not found
     */
    default boolean removeContainer(@NotNull Block block) {
        if (!containsContainer(block))
            return false;
        BlockVector vector = block.getLocation().toVector().toBlockVector();
        getContainers().remove(vector);
        save();
        return true;
    }

    default boolean containsContainer(@NotNull Block block) {
        BlockVector blockVector = block.getLocation().toVector().toBlockVector();
        return getContainers().containsKey(blockVector);
    }

    default boolean addDoor(@NotNull Block block) {
        if (block.getType() == Material.IRON_DOOR) {
            Door door = (Door) block.getBlockData();
            if (door.getHalf() == Bisected.Half.TOP) {
                Block relative = block.getRelative(BlockFace.DOWN);
                if (relative.getType() != Material.IRON_DOOR) return false;
            }
            getDoors().add(block.getLocation().toVector().toBlockVector());
            save();
            return true;
        }
        if (block.getType() == Material.IRON_TRAPDOOR) {
            getDoors().add(block.getLocation().toVector().toBlockVector());
            save();
            return true;
        }
        return false;
    }

    default boolean removeDoor(@NotNull Block door) {
        BlockVector vector = door.getLocation().toVector().toBlockVector();
        if (!containsDoor(door))
            return false;
        getDoors().remove(vector);
        save();
        return true;
    }

    void save();

    boolean useDefaultLore();

}
